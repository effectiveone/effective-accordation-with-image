"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Popover = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _reactDom = require("@floating-ui/react-dom");

var _framerMotion = require("framer-motion");

var _compose = require("@wordpress/compose");

var _icons = require("@wordpress/icons");

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _primitives = require("@wordpress/primitives");

var _button = _interopRequireDefault(require("../button"));

var _scrollLock = _interopRequireDefault(require("../scroll-lock"));

var _slotFill = require("../slot-fill");

var _utils = require("./utils");

/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Name of slot in which popover should fill.
 *
 * @type {string}
 */
const SLOT_NAME = 'Popover'; // An SVG displaying a triangle facing down, filled with a solid
// color and bordered in such a way to create an arrow-like effect.
// Keeping the SVG's viewbox squared simplify the arrow positioning
// calculations.

const ArrowTriangle = () => (0, _element.createElement)(_primitives.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: `0 0 100 100`,
  className: "components-popover__triangle",
  role: "presentation"
}, (0, _element.createElement)(_primitives.Path, {
  className: "components-popover__triangle-bg",
  d: "M 0 0 L 50 50 L 100 0"
}), (0, _element.createElement)(_primitives.Path, {
  className: "components-popover__triangle-border",
  d: "M 0 0 L 50 50 L 100 0",
  vectorEffect: "non-scaling-stroke"
}));

const AnimatedWrapper = (0, _element.forwardRef)((_ref, forwardedRef) => {
  let {
    style: receivedInlineStyles,
    placement,
    shouldAnimate = false,
    ...props
  } = _ref;
  // When animating, animate only once (i.e. when the popover is opened), and
  // do not animate on subsequent prop changes (as it conflicts with
  // floating-ui's positioning updates).
  const [hasAnimatedOnce, setHasAnimatedOnce] = (0, _element.useState)(false);
  const shouldReduceMotion = (0, _framerMotion.useReducedMotion)();
  const {
    style: motionInlineStyles,
    ...otherMotionProps
  } = (0, _element.useMemo)(() => (0, _utils.placementToMotionAnimationProps)(placement), [placement]);
  const onAnimationComplete = (0, _element.useCallback)(() => setHasAnimatedOnce(true), []);
  const computedAnimationProps = shouldAnimate && !shouldReduceMotion ? {
    style: { ...motionInlineStyles,
      ...receivedInlineStyles
    },
    ...otherMotionProps,
    onAnimationComplete,
    animate: hasAnimatedOnce ? false : otherMotionProps.animate
  } : {
    animate: false,
    style: receivedInlineStyles
  };
  return (0, _element.createElement)(_framerMotion.motion.div, (0, _extends2.default)({}, computedAnimationProps, props, {
    ref: forwardedRef
  }));
});
const slotNameContext = (0, _element.createContext)(undefined);

const UnforwardedPopover = (props, forwardedRef) => {
  var _frameOffsetRef$curre, _frameOffsetRef$curre2, _frameOffsetRef$curre3, _frameOffsetRef$curre4;

  const {
    animate = true,
    headerTitle,
    onClose,
    children,
    className,
    noArrow = true,
    isAlternate,
    position,
    placement: placementProp = 'bottom-start',
    offset: offsetProp = 0,
    focusOnMount = 'firstElement',
    anchor,
    expandOnMobile,
    onFocusOutside,
    __unstableSlotName = SLOT_NAME,
    flip = true,
    resize = true,
    shift = false,
    // Deprecated props
    __unstableForcePosition,
    __unstableShift,
    anchorRef,
    anchorRect,
    getAnchorRect,
    range,
    // Rest
    ...contentProps
  } = props;

  if (range) {
    (0, _deprecated.default)('`range` prop in wp.components.Popover', {
      since: '6.1',
      version: '6.3'
    });
  }

  let computedFlipProp = flip;
  let computedResizeProp = resize;

  if (__unstableForcePosition !== undefined) {
    (0, _deprecated.default)('`__unstableForcePosition` prop wp.components.Popover', {
      since: '6.1',
      version: '6.3',
      alternative: '`flip={ false }` and  `resize={ false }`'
    }); // Back-compat, set the `flip` and `resize` props
    // to `false` to replicate `__unstableForcePosition`.

    computedFlipProp = !__unstableForcePosition;
    computedResizeProp = !__unstableForcePosition;
  }

  let shouldShift = shift;

  if (__unstableShift !== undefined) {
    (0, _deprecated.default)('`__unstableShift` prop in wp.components.Popover', {
      since: '6.1',
      version: '6.3',
      alternative: '`shift` prop`'
    }); // Back-compat.

    shouldShift = __unstableShift;
  }

  if (anchorRef !== undefined) {
    (0, _deprecated.default)('`anchorRef` prop in wp.components.Popover', {
      since: '6.1',
      version: '6.3',
      alternative: '`anchor` prop'
    });
  }

  if (anchorRect !== undefined) {
    (0, _deprecated.default)('`anchorRect` prop in wp.components.Popover', {
      since: '6.1',
      version: '6.3',
      alternative: '`anchor` prop'
    });
  }

  if (getAnchorRect !== undefined) {
    (0, _deprecated.default)('`getAnchorRect` prop in wp.components.Popover', {
      since: '6.1',
      version: '6.3',
      alternative: '`anchor` prop'
    });
  }

  const arrowRef = (0, _element.useRef)(null);
  const [fallbackReferenceElement, setFallbackReferenceElement] = (0, _element.useState)(null);
  const [referenceOwnerDocument, setReferenceOwnerDocument] = (0, _element.useState)();
  const anchorRefFallback = (0, _element.useCallback)(node => {
    setFallbackReferenceElement(node);
  }, []);
  const isMobileViewport = (0, _compose.useViewportMatch)('medium', '<');
  const isExpanded = expandOnMobile && isMobileViewport;
  const hasArrow = !isExpanded && !noArrow;
  const normalizedPlacementFromProps = position ? (0, _utils.positionToPlacement)(position) : placementProp;
  /**
   * Offsets the position of the popover when the anchor is inside an iframe.
   *
   * Store the offset in a ref, due to constraints with floating-ui:
   * https://floating-ui.com/docs/react-dom#variables-inside-middleware-functions.
   */

  const frameOffsetRef = (0, _element.useRef)((0, _utils.getFrameOffset)(referenceOwnerDocument));
  /**
   * Store the offset prop in a ref, due to constraints with floating-ui:
   * https://floating-ui.com/docs/react-dom#variables-inside-middleware-functions.
   */

  const offsetRef = (0, _element.useRef)(offsetProp);
  const middleware = [(0, _reactDom.offset)(_ref2 => {
    let {
      placement: currentPlacement
    } = _ref2;

    if (!frameOffsetRef.current) {
      return offsetRef.current;
    }

    const isTopBottomPlacement = currentPlacement.includes('top') || currentPlacement.includes('bottom'); // The main axis should represent the gap between the
    // floating element and the reference element. The cross
    // axis is always perpendicular to the main axis.

    const mainAxis = isTopBottomPlacement ? 'y' : 'x';
    const crossAxis = mainAxis === 'x' ? 'y' : 'x'; // When the popover is before the reference, subtract the offset,
    // of the main axis else add it.

    const hasBeforePlacement = currentPlacement.includes('top') || currentPlacement.includes('left');
    const mainAxisModifier = hasBeforePlacement ? -1 : 1;
    return {
      mainAxis: offsetRef.current + frameOffsetRef.current[mainAxis] * mainAxisModifier,
      crossAxis: frameOffsetRef.current[crossAxis]
    };
  }), computedFlipProp ? (0, _reactDom.flip)() : undefined, computedResizeProp ? (0, _reactDom.size)({
    apply(sizeProps) {
      var _refs$floating$curren;

      const {
        firstElementChild
      } = (_refs$floating$curren = refs.floating.current) !== null && _refs$floating$curren !== void 0 ? _refs$floating$curren : {}; // Only HTMLElement instances have the `style` property.

      if (!(firstElementChild instanceof HTMLElement)) return; // Reduce the height of the popover to the available space.

      Object.assign(firstElementChild.style, {
        maxHeight: `${sizeProps.availableHeight}px`,
        overflow: 'auto'
      });
    }

  }) : undefined, shouldShift ? (0, _reactDom.shift)({
    crossAxis: true,
    limiter: (0, _reactDom.limitShift)(),
    padding: 1 // Necessary to avoid flickering at the edge of the viewport.

  }) : undefined, (0, _reactDom.arrow)({
    element: arrowRef
  })].filter(m => m !== undefined);

  const slotName = (0, _element.useContext)(slotNameContext) || __unstableSlotName;

  const slot = (0, _slotFill.useSlot)(slotName);
  let onDialogClose;

  if (onClose || onFocusOutside) {
    onDialogClose = (type, event) => {
      // Ideally the popover should have just a single onClose prop and
      // not three props that potentially do the same thing.
      if (type === 'focus-outside' && onFocusOutside) {
        onFocusOutside(event);
      } else if (onClose) {
        onClose();
      }
    };
  }

  const [dialogRef, dialogProps] = (0, _compose.__experimentalUseDialog)({
    focusOnMount,
    __unstableOnClose: onDialogClose,
    // @ts-expect-error The __unstableOnClose property needs to be deprecated first (see https://github.com/WordPress/gutenberg/pull/27675)
    onClose: onDialogClose
  });
  const {
    // Positioning coordinates
    x,
    y,
    // Callback refs (not regular refs). This allows the position to be updated.
    // when either elements change.
    reference: referenceCallbackRef,
    floating,
    // Object with "regular" refs to both "reference" and "floating"
    refs,
    // Type of CSS position property to use (absolute or fixed)
    strategy,
    update,
    placement: computedPlacement,
    middlewareData: {
      arrow: arrowData
    }
  } = (0, _reactDom.useFloating)({
    placement: normalizedPlacementFromProps,
    middleware,
    whileElementsMounted: (referenceParam, floatingParam, updateParam) => (0, _reactDom.autoUpdate)(referenceParam, floatingParam, updateParam, {
      animationFrame: true
    })
  });
  (0, _element.useEffect)(() => {
    offsetRef.current = offsetProp;
    update();
  }, [offsetProp, update]);
  const arrowCallbackRef = (0, _element.useCallback)(node => {
    arrowRef.current = node;
    update();
  }, [update]); // When any of the possible anchor "sources" change,
  // recompute the reference element (real or virtual) and its owner document.

  (0, _element.useLayoutEffect)(() => {
    const resultingReferenceOwnerDoc = (0, _utils.getReferenceOwnerDocument)({
      anchor,
      anchorRef,
      anchorRect,
      getAnchorRect,
      fallbackReferenceElement,
      fallbackDocument: document
    });
    const resultingReferenceElement = (0, _utils.getReferenceElement)({
      anchor,
      anchorRef,
      anchorRect,
      getAnchorRect,
      fallbackReferenceElement
    });
    referenceCallbackRef(resultingReferenceElement);
    setReferenceOwnerDocument(resultingReferenceOwnerDoc);
  }, [anchor, anchorRef, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.top, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.bottom, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.startContainer, anchorRef === null || anchorRef === void 0 ? void 0 : anchorRef.current, anchorRect, getAnchorRect, fallbackReferenceElement, referenceCallbackRef]); // If the reference element is in a different ownerDocument (e.g. iFrame),
  // we need to manually update the floating's position as the reference's owner
  // document scrolls. Also update the frame offset if the view resizes.

  (0, _element.useLayoutEffect)(() => {
    var _refs$floating, _refs$floating$curren2, _referenceOwnerDocume;

    if ( // Reference and root documents are the same.
    referenceOwnerDocument === document || // Reference and floating are in the same document.
    referenceOwnerDocument === (refs === null || refs === void 0 ? void 0 : (_refs$floating = refs.floating) === null || _refs$floating === void 0 ? void 0 : (_refs$floating$curren2 = _refs$floating.current) === null || _refs$floating$curren2 === void 0 ? void 0 : _refs$floating$curren2.ownerDocument) || // The reference's document has no view (i.e. window)
    // or frame element (ie. it's not an iframe).
    !(referenceOwnerDocument !== null && referenceOwnerDocument !== void 0 && (_referenceOwnerDocume = referenceOwnerDocument.defaultView) !== null && _referenceOwnerDocume !== void 0 && _referenceOwnerDocume.frameElement)) {
      frameOffsetRef.current = undefined;
      return;
    }

    const {
      defaultView
    } = referenceOwnerDocument;

    const updateFrameOffset = () => {
      frameOffsetRef.current = (0, _utils.getFrameOffset)(referenceOwnerDocument);
      update();
    };

    defaultView.addEventListener('resize', updateFrameOffset);
    updateFrameOffset();
    return () => {
      defaultView.removeEventListener('resize', updateFrameOffset);
    };
  }, [referenceOwnerDocument, update]);
  const mergedFloatingRef = (0, _compose.useMergeRefs)([floating, dialogRef, forwardedRef]); // Disable reason: We care to capture the _bubbled_ events from inputs
  // within popover as inferring close intent.

  let content = // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
  // eslint-disable-next-line jsx-a11y/no-static-element-interactions
  (0, _element.createElement)(AnimatedWrapper, (0, _extends2.default)({
    shouldAnimate: animate && !isExpanded,
    placement: computedPlacement,
    className: (0, _classnames.default)('components-popover', className, {
      'is-expanded': isExpanded,
      'is-alternate': isAlternate
    })
  }, contentProps, {
    ref: mergedFloatingRef
  }, dialogProps, {
    tabIndex: -1,
    style: isExpanded ? undefined : {
      position: strategy,
      left: Number.isNaN(x) ? 0 : x !== null && x !== void 0 ? x : undefined,
      top: Number.isNaN(y) ? 0 : y !== null && y !== void 0 ? y : undefined
    }
  }), isExpanded && (0, _element.createElement)(_scrollLock.default, null), isExpanded && (0, _element.createElement)("div", {
    className: "components-popover__header"
  }, (0, _element.createElement)("span", {
    className: "components-popover__header-title"
  }, headerTitle), (0, _element.createElement)(_button.default, {
    className: "components-popover__close",
    icon: _icons.close,
    onClick: onClose
  })), (0, _element.createElement)("div", {
    className: "components-popover__content"
  }, children), hasArrow && (0, _element.createElement)("div", {
    ref: arrowCallbackRef,
    className: ['components-popover__arrow', `is-${computedPlacement.split('-')[0]}`].join(' '),
    style: {
      left: typeof (arrowData === null || arrowData === void 0 ? void 0 : arrowData.x) !== 'undefined' && Number.isFinite(arrowData.x) ? `${arrowData.x + ((_frameOffsetRef$curre = (_frameOffsetRef$curre2 = frameOffsetRef.current) === null || _frameOffsetRef$curre2 === void 0 ? void 0 : _frameOffsetRef$curre2.x) !== null && _frameOffsetRef$curre !== void 0 ? _frameOffsetRef$curre : 0)}px` : '',
      top: typeof (arrowData === null || arrowData === void 0 ? void 0 : arrowData.y) !== 'undefined' && Number.isFinite(arrowData.y) ? `${arrowData.y + ((_frameOffsetRef$curre3 = (_frameOffsetRef$curre4 = frameOffsetRef.current) === null || _frameOffsetRef$curre4 === void 0 ? void 0 : _frameOffsetRef$curre4.y) !== null && _frameOffsetRef$curre3 !== void 0 ? _frameOffsetRef$curre3 : 0)}px` : ''
    }
  }, (0, _element.createElement)(ArrowTriangle, null)));

  if (slot.ref) {
    content = (0, _element.createElement)(_slotFill.Fill, {
      name: slotName
    }, content);
  }

  if (anchorRef || anchorRect || anchor) {
    return content;
  }

  return (0, _element.createElement)("span", {
    ref: anchorRefFallback
  }, content);
};
/**
 * `Popover` renders its content in a floating modal. If no explicit anchor is passed via props, it anchors to its parent element by default.
 *
 * ```jsx
 * import { Button, Popover } from '@wordpress/components';
 * import { useState } from '@wordpress/element';
 *
 * const MyPopover = () => {
 * 	const [ isVisible, setIsVisible ] = useState( false );
 * 	const toggleVisible = () => {
 * 		setIsVisible( ( state ) => ! state );
 * 	};
 *
 * 	return (
 * 		<Button variant="secondary" onClick={ toggleVisible }>
 * 			Toggle Popover!
 * 			{ isVisible && <Popover>Popover is toggled!</Popover> }
 * 		</Button>
 * 	);
 * };
 * ```
 *
 */


const Popover = (0, _element.forwardRef)(UnforwardedPopover);
exports.Popover = Popover;

function PopoverSlot(_ref3, ref) {
  let {
    name = SLOT_NAME
  } = _ref3;
  return (0, _element.createElement)(_slotFill.Slot // @ts-expect-error Need to type `SlotFill`
  , {
    bubblesVirtually: true,
    name: name,
    className: "popover-slot",
    ref: ref
  });
} // @ts-expect-error For Legacy Reasons


Popover.Slot = (0, _element.forwardRef)(PopoverSlot); // @ts-expect-error For Legacy Reasons

Popover.__unstableSlotNameProvider = slotNameContext.Provider;
var _default = Popover;
exports.default = _default;
//# sourceMappingURL=index.js.map