"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _element = require("@wordpress/element");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classnames = _interopRequireDefault(require("classnames"));

var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));

var _i18n = require("@wordpress/i18n");

var _icons = require("@wordpress/icons");

var _baseControl = require("../base-control");

var _button = _interopRequireDefault(require("../button"));

var _rangeControl = _interopRequireDefault(require("../range-control"));

var _flex = require("../flex");

var _unitControl = _interopRequireWildcard(require("../unit-control"));

var _customSelectControl = _interopRequireDefault(require("../custom-select-control"));

var _visuallyHidden = require("../visually-hidden");

var _toggleGroupControl = require("../toggle-group-control");

var _utils = require("./utils");

var _vStack = require("../v-stack");

var _hStack = require("../h-stack");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
// This conditional is needed to maintain the spacing before the slider in the `withSlider` case.
const MaybeVStack = _ref => {
  let {
    __nextHasNoMarginBottom,
    children
  } = _ref;
  return !__nextHasNoMarginBottom ? children : (0, _element.createElement)(_vStack.VStack, {
    spacing: 6,
    children: children
  });
};

function FontSizePicker(_ref2, ref) {
  var _fontSizes$, _value$endsWith;

  let {
    /** Start opting into the new margin-free styles that will become the default in a future version. */
    __nextHasNoMarginBottom = false,
    fallbackFontSize,
    fontSizes = [],
    disableCustomFontSizes = false,
    onChange,

    /** @type {'default' | '__unstable-large'} */
    size = 'default',
    value,
    withSlider = false,
    withReset = true
  } = _ref2;

  if (!__nextHasNoMarginBottom) {
    (0, _deprecated.default)('Bottom margin styles for wp.components.FontSizePicker', {
      since: '6.1',
      version: '6.4',
      hint: 'Set the `__nextHasNoMarginBottom` prop to true to start opting into the new styles, which will become the default in a future version.'
    });
  }

  const hasUnits = [typeof value, typeof (fontSizes === null || fontSizes === void 0 ? void 0 : (_fontSizes$ = fontSizes[0]) === null || _fontSizes$ === void 0 ? void 0 : _fontSizes$.size)].includes('string');
  const noUnitsValue = !hasUnits ? value : parseInt(value);
  const isPixelValue = typeof value === 'number' || (value === null || value === void 0 ? void 0 : (_value$endsWith = value.endsWith) === null || _value$endsWith === void 0 ? void 0 : _value$endsWith.call(value, 'px'));
  const units = (0, _unitControl.useCustomUnits)({
    availableUnits: ['px', 'em', 'rem']
  });
  /**
   * The main font size UI displays a toggle group when the presets are less
   * than six and a select control when they are more.
   */

  const fontSizesContainComplexValues = fontSizes.some(_ref3 => {
    let {
      size: sizeArg
    } = _ref3;
    return !(0, _utils.isSimpleCssValue)(sizeArg);
  });
  const shouldUseSelectControl = fontSizes.length > 5;
  const options = (0, _element.useMemo)(() => (0, _utils.getFontSizeOptions)(shouldUseSelectControl, fontSizes, disableCustomFontSizes), [shouldUseSelectControl, fontSizes, disableCustomFontSizes]);
  const selectedOption = (0, _utils.getSelectedOption)(fontSizes, value);
  const isCustomValue = selectedOption.slug === _utils.CUSTOM_FONT_SIZE;
  const [showCustomValueControl, setShowCustomValueControl] = (0, _element.useState)(!disableCustomFontSizes && isCustomValue);
  const headerHint = (0, _element.useMemo)(() => {
    if (showCustomValueControl) {
      return `(${(0, _i18n.__)('Custom')})`;
    } // If we have a custom value that is not available in the font sizes,
    // show it as a hint as long as it's a simple CSS value.


    if (isCustomValue) {
      return (0, _utils.isSimpleCssValue)(value) && `(${value})`;
    }

    if (shouldUseSelectControl) {
      return (0, _utils.isSimpleCssValue)(selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.size) && `(${selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.size})`;
    } // Calculate the `hint` for toggle group control.


    let hint = selectedOption.name;

    if (!fontSizesContainComplexValues && typeof selectedOption.size === 'string') {
      const [, unit] = (0, _utils.splitValueAndUnitFromSize)(selectedOption.size);
      hint += `(${unit})`;
    }

    return hint;
  }, [showCustomValueControl, selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.name, selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.size, value, isCustomValue, shouldUseSelectControl, fontSizesContainComplexValues]);

  if (!options) {
    return null;
  } // This is used for select control only. We need to add support
  // for ToggleGroupControl.


  const currentFontSizeSR = (0, _i18n.sprintf)( // translators: %s: Currently selected font size.
  (0, _i18n.__)('Currently selected font size: %s'), selectedOption.name);
  const baseClassName = 'components-font-size-picker';
  return (0, _element.createElement)("fieldset", (0, _extends2.default)({
    className: baseClassName
  }, ref ? {} : {
    ref
  }), (0, _element.createElement)(_visuallyHidden.VisuallyHidden, {
    as: "legend"
  }, (0, _i18n.__)('Font size')), (0, _element.createElement)(_hStack.HStack, {
    className: `${baseClassName}__header`
  }, (0, _element.createElement)(_baseControl.BaseControl.VisualLabel, null, (0, _i18n.__)('Size'), headerHint && (0, _element.createElement)("span", {
    className: `${baseClassName}__header__hint`
  }, headerHint)), !disableCustomFontSizes && (0, _element.createElement)(_button.default, {
    label: showCustomValueControl ? (0, _i18n.__)('Use size preset') : (0, _i18n.__)('Set custom size'),
    icon: _icons.settings,
    onClick: () => {
      setShowCustomValueControl(!showCustomValueControl);
    },
    isPressed: showCustomValueControl,
    isSmall: true
  })), (0, _element.createElement)(MaybeVStack, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom
  }, (0, _element.createElement)("div", {
    className: (0, _classnames.default)(`${baseClassName}__controls`, {
      'is-next-has-no-margin-bottom': __nextHasNoMarginBottom
    })
  }, !!fontSizes.length && shouldUseSelectControl && !showCustomValueControl && (0, _element.createElement)(_customSelectControl.default, {
    __nextUnconstrainedWidth: true,
    className: `${baseClassName}__select`,
    label: (0, _i18n.__)('Font size'),
    hideLabelFromVision: true,
    describedBy: currentFontSizeSR,
    options: options,
    value: options.find(option => option.key === selectedOption.slug),
    onChange: _ref4 => {
      let {
        selectedItem
      } = _ref4;
      onChange(hasUnits ? selectedItem.size : Number(selectedItem.size));

      if (selectedItem.key === _utils.CUSTOM_FONT_SIZE) {
        setShowCustomValueControl(true);
      }
    },
    size: size
  }), !shouldUseSelectControl && !showCustomValueControl && (0, _element.createElement)(_toggleGroupControl.ToggleGroupControl, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    label: (0, _i18n.__)('Font size'),
    hideLabelFromVision: true,
    value: value,
    onChange: newValue => {
      onChange(hasUnits ? newValue : Number(newValue));
    },
    isBlock: true,
    size: size
  }, options.map(option => (0, _element.createElement)(_toggleGroupControl.ToggleGroupControlOption, {
    key: option.key,
    value: option.value,
    label: option.label,
    "aria-label": option.name,
    showTooltip: true
  }))), !withSlider && !disableCustomFontSizes && showCustomValueControl && (0, _element.createElement)(_flex.Flex, {
    justify: "space-between",
    className: `${baseClassName}__custom-size-control`
  }, (0, _element.createElement)(_flex.FlexItem, {
    isBlock: true
  }, (0, _element.createElement)(_unitControl.default, {
    label: (0, _i18n.__)('Custom'),
    labelPosition: "top",
    hideLabelFromVision: true,
    value: value,
    onChange: nextSize => {
      if (0 === parseFloat(nextSize) || !nextSize) {
        onChange(undefined);
      } else {
        onChange(hasUnits ? nextSize : parseInt(nextSize, 10));
      }
    },
    size: size,
    units: hasUnits ? units : []
  })), withReset && (0, _element.createElement)(_flex.FlexItem, {
    isBlock: true
  }, (0, _element.createElement)(_button.default, {
    className: "components-color-palette__clear",
    disabled: value === undefined,
    onClick: () => {
      onChange(undefined);
    },
    isSmall: true,
    variant: "secondary"
  }, (0, _i18n.__)('Reset'))))), withSlider && (0, _element.createElement)(_rangeControl.default, {
    __nextHasNoMarginBottom: __nextHasNoMarginBottom,
    className: `${baseClassName}__custom-input`,
    label: (0, _i18n.__)('Custom Size'),
    value: isPixelValue && noUnitsValue || '',
    initialPosition: fallbackFontSize,
    onChange: newValue => {
      onChange(hasUnits ? newValue + 'px' : newValue);
    },
    min: 12,
    max: 100
  })));
}

var _default = (0, _element.forwardRef)(FontSizePicker);

exports.default = _default;
//# sourceMappingURL=index.js.map